name: GitHub Swarm Automation

on:
  issues:
    types: [opened, edited, reopened, labeled]
  pull_request:
    types: [opened, synchronize, ready_for_review, closed]
  push:
    branches: [main, develop]
  workflow_run:
    workflows: ["CI", "Security Scan", "Production Deploy"]
    types: [completed]
  schedule:
    # Daily security scan at 2:00 AM UTC
    - cron: '0 2 * * *'
    # Hourly infrastructure health check
    - cron: '0 * * * *'

concurrency:
  group: github-swarm-${{ github.event_name }}-${{ github.event.number || github.ref }}
  cancel-in-progress: false

env:
  SWARM_CONFIG: .claude/agents/github-swarm/swarm-config.json
  REPOSITORY: ${{ github.repository }}

jobs:
  # Issue Triage Agent
  issue-triage:
    name: Issue Triage
    if: github.event_name == 'issues'
    runs-on: ubuntu-latest
    permissions:
      issues: write
      contents: read
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: Install dependencies
        run: |
          pip install pyyaml requests

      - name: Triage Issue
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          ISSUE_NUMBER: ${{ github.event.issue.number }}
          ISSUE_TITLE: ${{ github.event.issue.title }}
          ISSUE_BODY: ${{ github.event.issue.body }}
          ISSUE_AUTHOR: ${{ github.event.issue.user.login }}
        run: |
          python << 'EOF'
          import os
          import re
          import json
          import requests

          # Configuration
          REPO = os.environ['REPOSITORY']
          TOKEN = os.environ['GITHUB_TOKEN']
          ISSUE_NUM = os.environ['ISSUE_NUMBER']
          TITLE = os.environ.get('ISSUE_TITLE', '')
          BODY = os.environ.get('ISSUE_BODY', '')

          # Type detection patterns
          TYPE_PATTERNS = {
              'bug': [r'(?i)error|exception|crash|fail|broken|doesn\'t work|unexpected|wrong'],
              'feature': [r'(?i)add|new|implement|create|introduce|would like|request'],
              'security': [r'(?i)CVE|vulnerability|exploit|injection|secret|credential|auth'],
              'performance': [r'(?i)slow|timeout|memory|cpu|latency|performance'],
              'documentation': [r'(?i)docs|readme|instructions|unclear|documentation'],
              'infrastructure': [r'(?i)docker|deploy|ci|workflow|monitoring|kubernetes'],
              'testing': [r'(?i)test|coverage|flaky|assertion']
          }

          # Component detection
          COMPONENT_PATTERNS = {
              'backend': [r'(?i)fastapi|endpoint|api|celery|worker|python'],
              'frontend': [r'(?i)react|component|ui|dashboard|typescript'],
              'ml-models': [r'(?i)prophet|xgboost|prediction|model|training|ml'],
              'database': [r'(?i)postgresql|timescaledb|query|migration|database'],
              'data-pipeline': [r'(?i)airflow|dag|etl|ingestion|pipeline']
          }

          # Priority keywords
          PRIORITY_KEYWORDS = {
              'P0-critical': [r'(?i)production down|data loss|security breach|urgent|critical'],
              'P1-high': [r'(?i)major|blocking|security|important|high priority'],
              'P2-medium': [r'(?i)bug|issue|problem|moderate'],
              'P3-low': [r'(?i)minor|cosmetic|enhancement|nice to have']
          }

          def classify_issue(title, body):
              text = f"{title} {body}"
              labels = []

              # Detect type
              for label, patterns in TYPE_PATTERNS.items():
                  for pattern in patterns:
                      if re.search(pattern, text):
                          labels.append(label)
                          break

              # Detect components
              for label, patterns in COMPONENT_PATTERNS.items():
                  for pattern in patterns:
                      if re.search(pattern, text):
                          labels.append(label)
                          break

              # Detect priority
              priority = 'P2-medium'  # Default
              for p, patterns in PRIORITY_KEYWORDS.items():
                  for pattern in patterns:
                      if re.search(pattern, text):
                          priority = p
                          break
                  if priority != 'P2-medium':
                      break
              labels.append(priority)

              # Always add needs-triage
              labels.append('needs-triage')

              return list(set(labels))

          def add_labels(labels):
              url = f"https://api.github.com/repos/{REPO}/issues/{ISSUE_NUM}/labels"
              headers = {
                  "Authorization": f"token {TOKEN}",
                  "Accept": "application/vnd.github.v3+json"
              }
              response = requests.post(url, headers=headers, json={"labels": labels})
              return response.status_code == 200

          def add_comment(body):
              url = f"https://api.github.com/repos/{REPO}/issues/{ISSUE_NUM}/comments"
              headers = {
                  "Authorization": f"token {TOKEN}",
                  "Accept": "application/vnd.github.v3+json"
              }
              response = requests.post(url, headers=headers, json={"body": body})
              return response.status_code == 201

          # Main execution
          labels = classify_issue(TITLE, BODY)
          print(f"Detected labels: {labels}")

          # Add labels
          if add_labels(labels):
              print("Labels added successfully")
          else:
              print("Failed to add labels")

          # Add triage comment
          type_label = next((l for l in labels if l in TYPE_PATTERNS), 'unknown')
          priority_label = next((l for l in labels if l.startswith('P')), 'P2-medium')
          component_labels = [l for l in labels if l in COMPONENT_PATTERNS]

          comment = f"""## Triage Summary

          **Type**: {type_label}
          **Priority**: {priority_label}
          **Components**: {', '.join(component_labels) if component_labels else 'General'}

          ---
          *Triaged automatically by GitHub Swarm Issue Triager*
          """

          if add_comment(comment):
              print("Triage comment added")

          EOF

  # PR Review Agent (triggered on PR events)
  pr-review:
    name: PR Review Analysis
    if: github.event_name == 'pull_request' && (github.event.action == 'opened' || github.event.action == 'synchronize')
    runs-on: ubuntu-latest
    permissions:
      pull-requests: write
      contents: read
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'
          cache: 'pip'

      - name: Install dependencies
        run: |
          pip install pytest pytest-cov

      - name: Analyze PR Changes
        id: analysis
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          PR_NUMBER: ${{ github.event.pull_request.number }}
        run: |
          # Get changed files
          gh pr diff $PR_NUMBER --name-only > changed_files.txt
          echo "Changed files:"
          cat changed_files.txt

          # Count changes
          TOTAL_FILES=$(wc -l < changed_files.txt)
          BACKEND_FILES=$(grep -c "^backend/" changed_files.txt || echo 0)
          FRONTEND_FILES=$(grep -c "^frontend/" changed_files.txt || echo 0)
          TEST_FILES=$(grep -c "test" changed_files.txt || echo 0)

          echo "total_files=$TOTAL_FILES" >> $GITHUB_OUTPUT
          echo "backend_files=$BACKEND_FILES" >> $GITHUB_OUTPUT
          echo "frontend_files=$FRONTEND_FILES" >> $GITHUB_OUTPUT
          echo "test_files=$TEST_FILES" >> $GITHUB_OUTPUT

      - name: Run Tests with Coverage
        id: coverage
        continue-on-error: true
        run: |
          if [ -f requirements.txt ]; then
            pip install -r requirements.txt 2>/dev/null || true
          fi

          # Run pytest with coverage if tests exist
          if [ -d "tests" ] || [ -d "backend/tests" ]; then
            pytest tests/ backend/tests/ --cov=backend --cov-report=json --cov-report=term -q 2>/dev/null || true
            if [ -f coverage.json ]; then
              COVERAGE=$(python -c "import json; print(json.load(open('coverage.json'))['totals']['percent_covered'])" 2>/dev/null || echo "0")
              echo "coverage=$COVERAGE" >> $GITHUB_OUTPUT
            else
              echo "coverage=0" >> $GITHUB_OUTPUT
            fi
          else
            echo "coverage=N/A" >> $GITHUB_OUTPUT
          fi

      - name: Post PR Review Comment
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const analysis = {
              totalFiles: '${{ steps.analysis.outputs.total_files }}',
              backendFiles: '${{ steps.analysis.outputs.backend_files }}',
              frontendFiles: '${{ steps.analysis.outputs.frontend_files }}',
              testFiles: '${{ steps.analysis.outputs.test_files }}',
              coverage: '${{ steps.coverage.outputs.coverage }}'
            };

            const coverageNum = parseFloat(analysis.coverage) || 0;
            const coverageStatus = coverageNum >= 80 ? 'PASS' : (coverageNum >= 70 ? 'WARNING' : 'NEEDS IMPROVEMENT');

            const body = `## PR Review Analysis

            ### Changes Summary
            | Metric | Value |
            |--------|-------|
            | Files Changed | ${analysis.totalFiles} |
            | Backend Files | ${analysis.backendFiles} |
            | Frontend Files | ${analysis.frontendFiles} |
            | Test Files | ${analysis.testFiles} |

            ### Test Coverage
            - Coverage: **${analysis.coverage}%** (${coverageStatus})
            - Target: 80%

            ### Review Checklist
            - [ ] Code follows project conventions
            - [ ] Tests added for new functionality
            - [ ] Documentation updated if needed
            - [ ] No hardcoded secrets or credentials

            ---
            *Analyzed by GitHub Swarm PR Reviewer*`;

            await github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: body
            });

  # Security Scan Agent
  security-scan:
    name: Security Scan
    if: |
      github.event_name == 'pull_request' ||
      github.event_name == 'push' ||
      (github.event_name == 'schedule' && github.event.schedule == '0 2 * * *')
    runs-on: ubuntu-latest
    permissions:
      security-events: write
      contents: read
      pull-requests: write
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: Install security tools
        run: |
          pip install pip-audit safety bandit

      - name: Run pip-audit
        id: pip-audit
        continue-on-error: true
        run: |
          if [ -f requirements.txt ]; then
            pip-audit -r requirements.txt --format json > pip-audit.json 2>/dev/null || echo '{"vulnerabilities":[]}' > pip-audit.json
            VULN_COUNT=$(python -c "import json; print(len(json.load(open('pip-audit.json')).get('vulnerabilities', [])))" 2>/dev/null || echo 0)
            echo "vulnerabilities=$VULN_COUNT" >> $GITHUB_OUTPUT
          else
            echo "vulnerabilities=0" >> $GITHUB_OUTPUT
          fi

      - name: Run Bandit (Python Security)
        id: bandit
        continue-on-error: true
        run: |
          if [ -d "backend" ]; then
            bandit -r backend/ -f json -o bandit.json 2>/dev/null || echo '{"results":[]}' > bandit.json
            ISSUES=$(python -c "import json; d=json.load(open('bandit.json')); print(len(d.get('results', [])))" 2>/dev/null || echo 0)
            echo "issues=$ISSUES" >> $GITHUB_OUTPUT
          else
            echo "issues=0" >> $GITHUB_OUTPUT
          fi

      - name: Check for secrets
        id: secrets
        run: |
          # Simple secret detection (add gitleaks for production)
          SECRET_PATTERNS="(api[_-]?key|secret|password|token|credential).*[=:].*['\"][^'\"]{8,}['\"]"
          SECRETS_FOUND=$(grep -rE "$SECRET_PATTERNS" --include="*.py" --include="*.ts" --include="*.js" backend/ frontend/ 2>/dev/null | wc -l || echo 0)
          echo "secrets_found=$SECRETS_FOUND" >> $GITHUB_OUTPUT

      - name: Post Security Report
        if: github.event_name == 'pull_request'
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const vulns = '${{ steps.pip-audit.outputs.vulnerabilities }}';
            const issues = '${{ steps.bandit.outputs.issues }}';
            const secrets = '${{ steps.secrets.outputs.secrets_found }}';

            const hasIssues = parseInt(vulns) > 0 || parseInt(issues) > 0 || parseInt(secrets) > 0;
            const status = hasIssues ? 'ISSUES FOUND' : 'PASSED';

            const body = `## Security Scan Report

            ### Summary: **${status}**

            | Check | Result |
            |-------|--------|
            | Dependency Vulnerabilities | ${vulns} found |
            | Code Security Issues (Bandit) | ${issues} found |
            | Potential Secret Exposure | ${secrets} patterns |

            ${hasIssues ? '### Action Required\nPlease review and address security findings before merging.' : '### All Clear\nNo critical security issues detected.'}

            ---
            *Scanned by GitHub Swarm Security Agent*`;

            await github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: body
            });

  # Infrastructure Health Check
  infrastructure-check:
    name: Infrastructure Health
    if: |
      (github.event_name == 'schedule' && github.event.schedule == '0 * * * *') ||
      (github.event_name == 'workflow_run')
    runs-on: ubuntu-latest
    permissions:
      actions: read
      contents: read
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Check Docker Configurations
        id: docker
        run: |
          ISSUES=0

          # Check docker-compose files exist
          for file in docker-compose.yml docker-compose.prod.yml; do
            if [ ! -f "$file" ]; then
              echo "Missing: $file"
              ISSUES=$((ISSUES + 1))
            fi
          done

          # Check for healthchecks in docker-compose
          if [ -f docker-compose.yml ]; then
            if ! grep -q "healthcheck" docker-compose.yml; then
              echo "Warning: No healthchecks in docker-compose.yml"
              ISSUES=$((ISSUES + 1))
            fi
          fi

          echo "issues=$ISSUES" >> $GITHUB_OUTPUT

      - name: Check CI/CD Health
        id: cicd
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # Get recent workflow runs
          RUNS=$(gh run list --limit 20 --json status,conclusion)
          SUCCESS=$(echo "$RUNS" | jq '[.[] | select(.conclusion == "success")] | length')
          TOTAL=$(echo "$RUNS" | jq 'length')

          if [ "$TOTAL" -gt 0 ]; then
            RATE=$(echo "scale=1; $SUCCESS * 100 / $TOTAL" | bc)
          else
            RATE=100
          fi

          echo "success_rate=$RATE" >> $GITHUB_OUTPUT
          echo "CI/CD Success Rate: $RATE%"

      - name: Generate Health Report
        run: |
          echo "## Infrastructure Health Report"
          echo ""
          echo "| Check | Status |"
          echo "|-------|--------|"
          echo "| Docker Config | ${{ steps.docker.outputs.issues == '0' && 'OK' || 'Issues Found' }} |"
          echo "| CI/CD Success Rate | ${{ steps.cicd.outputs.success_rate }}% |"
          echo ""
          echo "*Checked by GitHub Swarm Infrastructure Agent*"

  # Documentation Check (on PR merge)
  documentation-check:
    name: Documentation Check
    if: github.event_name == 'pull_request' && github.event.action == 'closed' && github.event.pull_request.merged == true
    runs-on: ubuntu-latest
    permissions:
      issues: write
      contents: read
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Check Documentation Needs
        id: docs
        run: |
          # Get merged PR files
          FILES=$(git diff --name-only HEAD~1)

          NEEDS_API_DOCS=false
          NEEDS_README=false

          # Check if API files changed
          if echo "$FILES" | grep -q "backend/api/"; then
            NEEDS_API_DOCS=true
          fi

          # Check if significant changes
          if echo "$FILES" | grep -qE "(docker-compose|requirements\.txt|package\.json)"; then
            NEEDS_README=true
          fi

          echo "needs_api_docs=$NEEDS_API_DOCS" >> $GITHUB_OUTPUT
          echo "needs_readme=$NEEDS_README" >> $GITHUB_OUTPUT

      - name: Create Documentation Issue
        if: steps.docs.outputs.needs_api_docs == 'true' || steps.docs.outputs.needs_readme == 'true'
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const needsApi = '${{ steps.docs.outputs.needs_api_docs }}' === 'true';
            const needsReadme = '${{ steps.docs.outputs.needs_readme }}' === 'true';

            let body = `## Documentation Update Needed\n\n`;
            body += `PR #${{ github.event.pull_request.number }} was merged and may require documentation updates:\n\n`;

            if (needsApi) {
              body += `- [ ] Update API documentation in \`docs/api/\`\n`;
            }
            if (needsReadme) {
              body += `- [ ] Review and update README.md\n`;
            }

            body += `\n---\n*Created by GitHub Swarm Documentation Agent*`;

            await github.rest.issues.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: `docs: Update documentation for PR #${{ github.event.pull_request.number }}`,
              body: body,
              labels: ['documentation', 'P3-low']
            });

  # Board Sync after Issue Triage
  board-sync-after-triage:
    name: Sync Board After Triage
    needs: issue-triage
    if: always() && needs.issue-triage.result == 'success'
    runs-on: ubuntu-latest
    permissions:
      issues: write
      contents: read
      repository-repository-projects: write
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Sync to GitHub Projects Board
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          ISSUE_NUMBER: ${{ github.event.issue.number }}
          ISSUE_URL: ${{ github.event.issue.html_url }}
        run: |
          set -euo pipefail

          REPO_OWNER="${GITHUB_REPOSITORY_OWNER}"

          # Find project
          PROJECT_ID=$(gh project list --owner "$REPO_OWNER" --format json 2>/dev/null | \
            jq -r '.projects[] | select(.title | contains("Investment Analysis")) | .id' | head -1 || echo "")

          if [[ -z "$PROJECT_ID" || "$PROJECT_ID" == "null" ]]; then
            echo "Project not found, creating..."
            PROJECT_ID=$(gh project create --owner "$REPO_OWNER" \
              --title "Investment Analysis Platform" \
              --format json 2>/dev/null | jq -r '.id' || echo "")
          fi

          if [[ -n "$PROJECT_ID" && "$PROJECT_ID" != "null" ]]; then
            echo "Adding issue #$ISSUE_NUMBER to project..."
            gh project item-add "$PROJECT_ID" --owner "$REPO_OWNER" --url "$ISSUE_URL" 2>/dev/null || true
            echo "Issue added to project board"
          else
            echo "::warning::Could not find or create project board"
          fi

      - name: Sync to Notion (if configured)
        env:
          NOTION_TOKEN: ${{ secrets.NOTION_TOKEN }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          ISSUE_NUMBER: ${{ github.event.issue.number }}
          ISSUE_TITLE: ${{ github.event.issue.title }}
          ISSUE_URL: ${{ github.event.issue.html_url }}
        run: |
          if [[ -z "$NOTION_TOKEN" ]]; then
            echo "Notion token not configured, skipping Notion sync"
            exit 0
          fi

          # Read database ID from config
          DATABASE_ID=""
          if [[ -f ".github/board-sync.yml" ]]; then
            DATABASE_ID=$(grep "database_id:" .github/board-sync.yml | awk '{print $2}' | tr -d '"' || echo "")
          fi

          if [[ -z "$DATABASE_ID" ]]; then
            echo "Notion database ID not configured, skipping"
            exit 0
          fi

          # Create Notion page for the issue
          python << 'EOF'
          import os
          import requests

          NOTION_TOKEN = os.environ.get('NOTION_TOKEN', '')
          DATABASE_ID = os.environ.get('DATABASE_ID', '')
          ISSUE_NUM = os.environ.get('ISSUE_NUMBER', '')
          ISSUE_TITLE = os.environ.get('ISSUE_TITLE', 'Untitled')
          ISSUE_URL = os.environ.get('ISSUE_URL', '')

          headers = {
              "Authorization": f"Bearer {NOTION_TOKEN}",
              "Content-Type": "application/json",
              "Notion-Version": "2022-06-28"
          }

          # Check if already exists
          query_url = f"https://api.notion.com/v1/databases/{DATABASE_ID}/query"
          query = {"filter": {"property": "GitHub Issue", "number": {"equals": int(ISSUE_NUM)}}}

          response = requests.post(query_url, headers=headers, json=query)
          if response.status_code == 200 and response.json().get('results'):
              print(f"Issue #{ISSUE_NUM} already exists in Notion")
              exit(0)

          # Create new page
          payload = {
              "parent": {"database_id": DATABASE_ID},
              "properties": {
                  "Name": {"title": [{"text": {"content": ISSUE_TITLE[:2000]}}]},
                  "Status": {"select": {"name": "To Do"}},
                  "Priority": {"select": {"name": "Medium"}},
                  "GitHub Issue": {"number": int(ISSUE_NUM)},
                  "GitHub URL": {"url": ISSUE_URL}
              }
          }

          create_url = "https://api.notion.com/v1/pages"
          response = requests.post(create_url, headers=headers, json=payload)

          if response.status_code == 200:
              print(f"Created Notion page for issue #{ISSUE_NUM}")
          else:
              print(f"Failed to create Notion page: {response.status_code}")
          EOF

  # Board Sync after PR Processing
  board-sync-after-pr:
    name: Sync Board After PR
    needs: [pr-review]
    if: always() && (needs.pr-review.result == 'success' || needs.pr-review.result == 'skipped')
    runs-on: ubuntu-latest
    permissions:
      pull-requests: write
      contents: read
      repository-repository-projects: write
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Sync PR to GitHub Projects Board
        if: github.event_name == 'pull_request'
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          PR_NUMBER: ${{ github.event.pull_request.number }}
          PR_URL: ${{ github.event.pull_request.html_url }}
          PR_STATE: ${{ github.event.pull_request.state }}
          PR_MERGED: ${{ github.event.pull_request.merged }}
        run: |
          set -euo pipefail

          REPO_OWNER="${GITHUB_REPOSITORY_OWNER}"

          # Find project
          PROJECT_ID=$(gh project list --owner "$REPO_OWNER" --format json 2>/dev/null | \
            jq -r '.projects[] | select(.title | contains("Investment Analysis")) | .id' | head -1 || echo "")

          if [[ -n "$PROJECT_ID" && "$PROJECT_ID" != "null" ]]; then
            echo "Adding PR #$PR_NUMBER to project..."
            gh project item-add "$PROJECT_ID" --owner "$REPO_OWNER" --url "$PR_URL" 2>/dev/null || true

            # Update linked issues if PR was merged
            if [[ "$PR_MERGED" == "true" ]]; then
              echo "PR was merged, updating linked issues..."

              # Get PR body to find linked issues
              PR_BODY=$(gh pr view "$PR_NUMBER" --json body --jq '.body' 2>/dev/null || echo "")

              # Extract issue references
              ISSUE_REFS=$(echo "$PR_BODY" | grep -oE "(close[sd]?|fix(es|ed)?|resolve[sd]?)\s*#[0-9]+" -i | grep -oE "#[0-9]+" || echo "")

              for ref in $ISSUE_REFS; do
                ISSUE_NUM=${ref#\#}
                echo "Marking issue #$ISSUE_NUM as done..."
                gh issue edit "$ISSUE_NUM" --add-label "done" 2>/dev/null || true
              done
            fi
          fi

      - name: Update Notion on PR Merge
        if: github.event_name == 'pull_request' && github.event.pull_request.merged == true
        env:
          NOTION_TOKEN: ${{ secrets.NOTION_TOKEN }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          PR_NUMBER: ${{ github.event.pull_request.number }}
        run: |
          if [[ -z "$NOTION_TOKEN" ]]; then
            echo "Notion token not configured, skipping"
            exit 0
          fi

          DATABASE_ID=""
          if [[ -f ".github/board-sync.yml" ]]; then
            DATABASE_ID=$(grep "database_id:" .github/board-sync.yml | awk '{print $2}' | tr -d '"' || echo "")
          fi

          if [[ -z "$DATABASE_ID" ]]; then
            exit 0
          fi

          # Get linked issues from PR
          PR_BODY=$(gh pr view "$PR_NUMBER" --json body --jq '.body' 2>/dev/null || echo "")
          ISSUE_REFS=$(echo "$PR_BODY" | grep -oE "(close[sd]?|fix(es|ed)?|resolve[sd]?)\s*#[0-9]+" -i | grep -oE "#[0-9]+" || echo "")

          for ref in $ISSUE_REFS; do
            ISSUE_NUM=${ref#\#}

            python << EOF
          import os
          import requests

          NOTION_TOKEN = os.environ.get('NOTION_TOKEN', '')
          DATABASE_ID = "$DATABASE_ID"
          ISSUE_NUM = "$ISSUE_NUM"

          headers = {
              "Authorization": f"Bearer {NOTION_TOKEN}",
              "Content-Type": "application/json",
              "Notion-Version": "2022-06-28"
          }

          # Find the page
          query_url = f"https://api.notion.com/v1/databases/{DATABASE_ID}/query"
          query = {"filter": {"property": "GitHub Issue", "number": {"equals": int(ISSUE_NUM)}}}

          response = requests.post(query_url, headers=headers, json=query)
          if response.status_code == 200:
              results = response.json().get('results', [])
              if results:
                  page_id = results[0]['id']
                  # Update status to Done
                  update_url = f"https://api.notion.com/v1/pages/{page_id}"
                  update_payload = {"properties": {"Status": {"select": {"name": "Done"}}}}
                  requests.patch(update_url, headers=headers, json=update_payload)
                  print(f"Updated issue #{ISSUE_NUM} to Done in Notion")
          EOF
          done

  # Workflow Completion Sync
  workflow-completion-sync:
    name: Sync on Workflow Completion
    if: github.event_name == 'workflow_run'
    runs-on: ubuntu-latest
    permissions:
      issues: write
      pull-requests: write
      contents: read
      repository-repository-projects: write
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Process Workflow Completion
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          WORKFLOW_NAME: ${{ github.event.workflow_run.name }}
          WORKFLOW_CONCLUSION: ${{ github.event.workflow_run.conclusion }}
          HEAD_SHA: ${{ github.event.workflow_run.head_sha }}
        run: |
          echo "Workflow '$WORKFLOW_NAME' completed with: $WORKFLOW_CONCLUSION"

          REPO_OWNER="${GITHUB_REPOSITORY_OWNER}"

          # Find related PRs
          PRS=$(gh pr list --json number,headRefOid --jq ".[] | select(.headRefOid == \"$HEAD_SHA\") | .number" 2>/dev/null || echo "")

          if [[ -n "$PRS" ]]; then
            for PR_NUM in $PRS; do
              echo "Found related PR: #$PR_NUM"

              if [[ "$WORKFLOW_CONCLUSION" == "success" ]]; then
                # Add success label
                gh pr edit "$PR_NUM" --add-label "ci-passed" --remove-label "ci-failed" 2>/dev/null || true
              elif [[ "$WORKFLOW_CONCLUSION" == "failure" ]]; then
                # Add failure label
                gh pr edit "$PR_NUM" --add-label "ci-failed" --remove-label "ci-passed" 2>/dev/null || true

                # Comment on PR about failure
                gh pr comment "$PR_NUM" --body "## CI Failed

                Workflow **$WORKFLOW_NAME** failed. Please check the [workflow run](https://github.com/$GITHUB_REPOSITORY/actions) for details.

                ---
                *Posted by GitHub Swarm Workflow Monitor*" 2>/dev/null || true
              fi
            done
          fi

      - name: Trigger Full Board Sync
        if: github.event.workflow_run.conclusion == 'success'
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # Trigger the auto-sync workflow for comprehensive sync
          gh workflow run auto-sync.yml --field sync_github=true --field sync_notion=true 2>/dev/null || \
            echo "Could not trigger auto-sync workflow (may not exist yet)"
